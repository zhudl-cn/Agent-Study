# Day 2: GGUF 文件二进制结构分析

> 学习日期：2026-01-26
> 分析模型：qwen2.5-0.5b-instruct-q4_k_m.gguf

---

## 一、GGUF 文件整体结构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        GGUF 文件结构                              │
├─────────────────────────────────────────────────────────────────┤
│  1. HEADER (文件头)                                              │
│     ├── Magic: GGUF (4 bytes)                       │
│     ├── Version: 3 (类型: uint32_t)                   │
│     ├── n_tensors: 291 (类型: uint64_t)                   │
│     └── n_kv: 26 (类型: uint64_t)                   │
├─────────────────────────────────────────────────────────────────┤
│  2. KV PAIRS (键值对元数据)                                       │
│     └── 请描述每个 KV pair 的存储格式：                            │
│         ├── Key: string              │
│         ├── Value Type: gguf_type              │
│         └── Value:  array other type              │
├─────────────────────────────────────────────────────────────────┤
│  3. TENSOR INFO (张量信息)                                       │
│     └── 请描述每个 tensor 的存储格式：                             │
│         ├── tensor name                 │
│         ├── tensor的维度                 │
│         ├── 每个维度的大小                 │
│         ├── 张量的数据类型 gguf_type                 │
│         └── 张量的数据偏移值                 │
├─────────────────────────────────────────────────────────────────┤
│  [PADDING] 对齐填充 (alignment = 32 bytes)                    │
├─────────────────────────────────────────────────────────────────┤
│  4. TENSOR DATA (张量数据二进制 blob)                            │
│     └── 可选，字节对齐后存储        │
└─────────────────────────────────────────────────────────────────┘
```

---

## 二、Header 详细分析

### 2.1 字段定义

| 字段 | 数据类型 | 大小 (bytes) | 用途 |
|------|----------|--------------|------|
| Magic | int32_t | char[4] | 文件标识 |
| Version | int32_t | 4 | 版本号 |
| n_tensors | int64_t|8 |表示张量数量 |
| n_kv | int64_t| 8| 表示kv对数量 |

**Header 总大小**：24 bytes

### 2.2 实际二进制验证

使用命令查看：
```bash
xxd -l 24 models/qwen2.5-0.5b-instruct-q4_k_m.gguf
```

输出结果：
```
00000000: 4747 5546 0300 0000 2301 0000 0000 0000  GGUF....#.......
00000010: 1a00 0000 0000 0000 
```

解析：
| 字节范围 | 十六进制 | 解析值 | 字段 |
|----------|----------|--------|------|
| 0-3 |4747 5546 |GGUF | Magic |
| 4-7 |0300 0000 |3 | Version |
| 8-15 |2301 0000 0000 0000 |291 | n_tensors |
| 16-23 |1a00 0000 0000 0000 |26 | n_kv |

---

## 三、KV Pairs 结构

### 3.1 字符串序列化规则

- 字符串存储格式：[len][str]
- 为什么不需要 null terminator？因为有长度信息，不要终止符判断

### 3.2 Qwen2.5-0.5B 模型的关键 KV Pairs

| 索引 | Key | 含义/用途 |
|------|-----|-----------|
| 0 | general.architecture | 模型架构 |
| 6 | qwen2.block_count | 块数量 |
| 7 | qwen2.context_length | 上下文长度 |
| 8 | qwen2.embedding_length | 嵌入长度 |
| 10 | qwen2.attention.head_count | 注意力头数 |

---

## 四、Tensor Info 结构

### 4.1 每个 Tensor 的元信息

| 属性 | 数据类型 | 说明 |
|------|----------|------|
| name | string | 张量名称 |
| n_dims | uint32_t | 维度数量 |
| dims | array of uint64_t | 每个维度的大小 |
| type | gguf_type | 数据类型 |
| offset | uint64_t | 数据偏移量 |

### 4.2 示例 Tensor（从实际输出中填写）

| Tensor 名称 | 大小 (bytes) | 偏移量 |
|-------------|--------------|--------|
| output.weight |144643072 | 0 |
| token_embd.weight |93592576 | 144643072 |
| blk.0.attn_norm.weight | 3584 | 238235648 |

---

## 五、关键数值总结

| 指标 | 值 | 说明 |
|------|-----|------|
| GGUF 版本 | 3 | |
| 对齐大小 | 32 | |
| 数据偏移 | 5947744 | Tensor Data Blob 的起始位置 |
| KV 对数量 | 26 | |
| Tensor 数量 | 291 | |

---

## 六、思考问题

1. **为什么使用小端序（Little Endian）？**

   当数据较小时，小端序可以让计算机快速读取到有效数据。x86/ARM 都是小端架构，直接存储和读取无需转换。


2. **mmap 内存映射如何工作？它的优势是什么？**

   mmap 可以将磁盘或这文件数据映射到内存中。可以快速读取文件或硬盘数据。可以补充——优势是避免数据复制。传统 read() 需要：磁盘→内核缓冲区→用户空间（两次拷贝）。mmap 直接映射，只有一次拷贝，而且支持按需加载（懒加载）。


3. **alignment（对齐）的作用是什么？为什么默认是 32 字节？**

   由于数据的长度不一，对齐可以统一存储方式，提高读取效率。因为 AVX2 SIMD 指令需要 256 位 = 32 字节对齐的数据才能高效执行。


---

## 七、参考资料

- 源码文件：`ggml/include/gguf.h`
- 源码文件：`ggml/src/gguf.cpp`
- 示例工具：`examples/gguf/gguf.cpp`
